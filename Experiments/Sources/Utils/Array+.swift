import Base
import UIKit

public extension Array {
    /* Get head and tail of the array. */
    var match: (head: Element, tail: [Element])? {
        if isEmpty {
            return nil
        }
        let head = self.first!
        let tail = Array(self[1..<count])
        
        return (head, tail)
    }
    
    /// Bounds checked array lookup
    subscript(safe index: Index) -> Element? {
        return indices.contains(index) ? self[index] : nil
    }
}

extension Array where Element: Comparable {
    public func withCappedValues(min minValue: Element, max maxValue: Element) -> [Element] {
        return self.map { item in
            return Swift.max(minValue, Swift.min(item, maxValue))
        }
    }
}

extension Array {
    public func chunked(into size: Int) -> [[Element]] {
        return stride(from: 0, to: count, by: size).map {
            Array(self[$0..<Swift.min($0 + size, count)])
        }
    }
}

extension Array {
    public func toDictionary<Key: Hashable>(with selectKey: (Element) -> Key) -> [Key: Element] {
        var dict = [Key: Element]()
        for element in self {
            dict[selectKey(element)] = element
        }
        return dict
    }
    
    /// Creates a new empty Array with the specified capacity
    /// - Parameter capacity: the capacity to reserve, but not fill
    public init(capacity: Int) {
        self.init()
        self.reserveCapacity(capacity)
    }
    
    /// Create a new Array whose values are generated by the given closure.
    /// - Parameters:
    ///     - count:            The number of elements to generate
    ///     - elementGenerator: The closure that generates the elements.
    ///                         The index into which the element will be
    ///                         inserted is passed into the closure.
    public init(generating elementGenerator: (Int) -> Element, count: Int) {
        self.init(capacity: count)
        for i in 0..<count {
            self.append(elementGenerator(i))
        }
    }
}

// Copied fastest algo from https://forums.swift.org/t/removing-elements-at-more-than-one-index-from-an-array/19953/3
// Edit (15/7/2021): added a couple of guards and a sanity check
extension Array {
    mutating func remove(elementsAtIndices indicesToRemove: [Int]) -> [Element] {
        guard !indicesToRemove.isEmpty else {
            return []
        }
        
        // Copy the removed elements in the specified order.
        let removedElements = indicesToRemove.map { self[safe: $0] }.compactMap { $0 }
        
        guard !removedElements.isEmpty else {
            return []
        }
        
        // Sort the indices to remove.
        let indicesToRemove = indicesToRemove.sorted()
        
        // Shift the elements we want to keep to the left.
        var destIndex = indicesToRemove.first!
        var srcIndex = destIndex + 1
        func shiftLeft(untilIndex index: Int) {
            while srcIndex < index {
                self[destIndex] = self[srcIndex]
                destIndex += 1
                srcIndex += 1
            }
            srcIndex += 1
        }
        for removeIndex in indicesToRemove[1...] {
            shiftLeft(untilIndex: removeIndex)
        }
        shiftLeft(untilIndex: self.endIndex)
        
        // Remove the extra elements from the end of the array.
        self.removeLast(indicesToRemove.count)
        
        return removedElements
    }
}

/// Remove duplicates from an array
extension Array where Element: Hashable {
    func removingDuplicates() -> [Element] {
        var addedDict = [Element: Bool]()
        
        return filter {
            addedDict.updateValue(true, forKey: $0) == nil
        }
    }
    
    mutating func removeDuplicates() {
        self = self.removingDuplicates()
    }
}

/// Remove duplicates from an array ordering elements by their frequency in the original array
extension Array where Element: Hashable {
    func removingDuplicatesByFrequency() -> [Element] {
        let counts = self.reduce(into: [Element: Int]()) { counts, element in
            counts[element, default: 0] += 1
        }
        
        var seen = Set<Element>()
        return self.sorted { counts[$0]! > counts[$1]! } // Sort by count
            .filter { seen.insert($0).inserted } // Remove duplicates, preserving order
    }
}

extension Array {
    /// Splits an array into multiple `Group` based on consecutive separator changes.
    ///
    /// - Parameter isSeparator: A closure that determines whether an element serves as a separator.
    /// - Returns: An array of `[Element]` where the elements are grouped according to the provided condition.
    ///
    /// Example:
    /// ```
    /// let input = [true, true, false, false, true]
    /// let groups = input.groupByCondition { $0 }
    /// Result: [[true, true], [false, false], [true]]
    /// ```
    func groupUntilChange(_ isSeparator: (Element) -> Bool) -> [[Element]] {
        return self.reduce(into: [[Element]]()) { partialResult, item in
            guard let lastGroup = partialResult.last else {
                partialResult.append([item])
                return
            }
            
            let isCurrentOccupied = isSeparator(item)
            let isLastOccupied = lastGroup.last.map { isSeparator($0) } ?? false
            
            if isCurrentOccupied == isLastOccupied {
                partialResult[partialResult.count - 1].append(item)
            } else {
                partialResult.append([item])
            }
        }
    }
    
    func grouped<Key: Hashable>(by transform: @escaping (Element) -> Key?) -> [Key: [Element]] {
        reduce(into: [Key: [Element]]()) { groups, element in
            guard let key = transform(element) else { return }
            groups[key, default: []].append(element)
        }
    }
}

extension Array where Element: Encodable {
    func toPrettyPrinted() -> String {
        do {
            let data = try JSONEncoder().encode(self)
            return String(data: data, encoding: .utf8) ?? "empty data"
        } catch {
            return error.localizedDescription
        }
    }
}
